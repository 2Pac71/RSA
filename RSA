import java.math.BigInteger;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom;

public class RSA {

    private static final String TOKEN = ";";

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Inserisci la stringa da crittografare:");
        String data = scanner.nextLine();

        Random rng = new Random();

        BigInteger fPrime = BigInteger.probablePrime(Long.BYTES, rng);
        BigInteger sPrime = BigInteger.probablePrime(Long.BYTES, rng);

        while (true) {
            if (fPrime.compareTo(sPrime) != 0) {
                if (sPrime.isProbablePrime(1)) {
                    if (fPrime.isProbablePrime(1)) {
                        long min = 30000;
                        if (sPrime.multiply(fPrime).compareTo(BigInteger.valueOf(min)) > 0) {
                            break;
                        }
                    } else {
                        fPrime = BigInteger.probablePrime(Long.BYTES, rng);
                    }
                } else {
                    sPrime = BigInteger.probablePrime(Long.BYTES, rng);
                }
            } else {
                fPrime = BigInteger.probablePrime(Long.BYTES, rng);
                sPrime = BigInteger.probablePrime(Long.BYTES, rng);
            }
        }

        System.out.println((sPrime.multiply(fPrime)).compareTo(new BigInteger("1000000")) >= 0);

        BigInteger n = fPrime.multiply(sPrime);

        BigInteger z = sPrime.subtract(BigInteger.ONE).multiply(fPrime.subtract(BigInteger.ONE));

        BigInteger e = coPrime(z);

        BigInteger d;

        int i = 2;
        while ((e.multiply(BigInteger.valueOf(i)).mod(z).compareTo(BigInteger.ONE)) != 0) {
            i = i + ThreadLocalRandom.current().nextInt(1, 2);
        }

        d = BigInteger.valueOf(i);

        System.out.println("FirstPrime --> " + fPrime + " secondPrime --> " + sPrime + " n --> " + n + " z --> " + z
                + " e --> " + e + " d --> " + d);

        String encryptedData = encrypt(data, e, n);

        System.out.println("ENCRYPTED --> " + encryptedData);

        decrypt(encryptedData, d, n);

        scanner.close();
    }

    private static String encrypt(String data, BigInteger e, BigInteger n) {
        Vector<BigInteger> intVector = new Vector<>();
        StringBuilder intList = new StringBuilder();

        char[] charRawVector = new char[data.length()];
        data.getChars(0, data.length(), charRawVector, 0);

        for (char character : charRawVector) {
            int i = (int) character;
            if (i != 13) {
                BigInteger c = new BigInteger(Integer.toString(i)).modPow(e, n);
                intVector.add(new BigInteger(Integer.toString(i)));
                intList.append(c);
                intList.append(TOKEN);
            } else {
                intList.append("\n");
            }
        }

        System.out.println("ENCRYPT --> " + intVector);
        return intList.toString();
    }

    private static void decrypt(String data, BigInteger d, BigInteger n) {
        StringTokenizer tokenizer = new StringTokenizer(data, TOKEN);

        Vector<BigInteger> intVector = new Vector<>();
        StringBuilder stringList = new StringBuilder();

        while (tokenizer.hasMoreTokens()) {
            data = tokenizer.nextToken();
            if (!data.isEmpty()) {
                int i = Integer.parseInt(data);
                BigInteger m = new BigInteger(Integer.toString(i)).modPow(d, n);
                intVector.add(m);
                stringList.append((char) m.longValueExact());
            } else {
                stringList.append("\n");
            }
        }

        System.out.println("DECRYPTED --> " + intVector);
        System.out.println("CHAR : DECRYPTED --> " + stringList);
    }

    private static BigInteger coPrime(BigInteger fPrime) {
        BigInteger coPrime;
        Random rng = new Random();
        while ((coPrime = BigInteger.probablePrime(Long.BYTES, rng)).compareTo(fPrime) > 0) {
        }
        return coPrime;
    }
}
